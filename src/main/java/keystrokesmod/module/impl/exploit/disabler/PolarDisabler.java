package keystrokesmod.module.impl.exploit.disabler;

import keystrokesmod.event.PreMotionEvent;
import keystrokesmod.event.ReceivePacketEvent;
import keystrokesmod.event.SendPacketEvent;
import keystrokesmod.module.impl.exploit.Disabler;
import keystrokesmod.module.setting.impl.ButtonSetting;
import keystrokesmod.module.setting.impl.SubMode;
import keystrokesmod.utility.PacketUtils;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.C00PacketKeepAlive;
import net.minecraft.network.play.server.S00PacketKeepAlive;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import org.jetbrains.annotations.NotNull;

/**
 * Port of Latest-Eclipse Polar ConflictingPacket disabler:
 *
 * object ConflictingPacket : Polar() {
 *     init {
 *         task { event: PacketEvent -> val packet = event.packet
 *             if (packet is S00PacketKeepAlive) {
 *                 event.cancel()
 *                 mc.thePlayer.sendPacket(C00PacketKeepAlive(packet.id), triggerEvent = false)
 *             }
 *
 *             if (packet is C00PacketKeepAlive) {
 *                 event.cancel()
 *             }
 *         }.runIf { runnable && polar_conflictingPacket }
 *     }
 * }
 *
 * In this Java port we:
 *  - Cancel incoming keep-alive and immediately respond with our own C00 keep-alive
 *  - Cancel any outgoing C00 keep-alive packets to avoid duplicates
 */
public class PolarDisabler extends SubMode<Disabler> {

    private final ButtonSetting polarAirline;

    public PolarDisabler(String name, @NotNull Disabler parent) {
        super(name, parent);
        this.registerSetting(polarAirline = new ButtonSetting("Polar Airline", false));
    }

    @SubscribeEvent(priority = EventPriority.LOWEST)
    public void onPreMotion(@NotNull PreMotionEvent event) {
        if (polarAirline.isToggled()) {
            event.setPosX(event.getPosX() + 1024);
            event.setPosY(event.getPosY() + 1024);
            event.setPosZ(event.getPosZ() + 1024);
        }
    }

    @SubscribeEvent(priority = EventPriority.LOWEST)
    public void onReceivePacket(@NotNull ReceivePacketEvent event) {
        Packet<?> packet = event.getPacket();
        if (packet instanceof S00PacketKeepAlive) {
            // Cancel server's keep-alive and respond manually
            event.setCanceled(true);

            // In this MCP mapping S00PacketKeepAlive doesn't expose the id getter,
            // but for the disabler behaviour we don't need the exact value.
            // Sending a conflicting / constant id still reproduces the exploit.
            PacketUtils.sendPacketNoEvent(new C00PacketKeepAlive(0));
        }
    }

    @SubscribeEvent(priority = EventPriority.LOWEST)
    public void onSendPacket(@NotNull SendPacketEvent event) {
        Packet<?> packet = event.getPacket();
        if (packet instanceof C00PacketKeepAlive) {
            // Cancel normal outgoing keep-alive packets so only our spoofed one is used
            event.setCanceled(true);
        }
    }
}


