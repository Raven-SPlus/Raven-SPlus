package keystrokesmod.module.impl.exploit.disabler;

import keystrokesmod.event.ReceivePacketEvent;
import keystrokesmod.event.SendPacketEvent;
import keystrokesmod.module.ModuleManager;
import keystrokesmod.module.impl.combat.KillAura;
import keystrokesmod.module.impl.exploit.Disabler;
import keystrokesmod.module.setting.impl.ButtonSetting;
import keystrokesmod.module.setting.impl.SubMode;
import keystrokesmod.utility.PacketUtils;
import keystrokesmod.utility.RotationUtils;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.network.Packet;
import net.minecraft.network.play.INetHandlerPlayClient;
import net.minecraft.network.play.client.C02PacketUseEntity;
import net.minecraft.network.play.client.C0APacketAnimation;
import net.minecraft.network.play.client.C03PacketPlayer;
import net.minecraft.network.play.client.C0FPacketConfirmTransaction;
import net.minecraft.network.play.server.S08PacketPlayerPosLook;
import net.minecraft.network.play.server.S32PacketConfirmTransaction;
import net.minecraftforge.fml.common.eventhandler.EventPriority;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import org.jetbrains.annotations.NotNull;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * Intave bypass disabler - ported from FireBounce Disabler.
 * Options: IntaveOld (resource pack cancel), IntaveCloudCheck (C0F queue),
 * IntaveReach (position spoof for long range), IntaveFly (S32 delay on S08).
 */
public class IntaveDisabler extends SubMode<Disabler> {

    private final ButtonSetting intaveOld;
    private final ButtonSetting intaveCloudCheck;
    private final ButtonSetting intaveReach;
    private final ButtonSetting intaveReachStrong;
    private final ButtonSetting intaveFly;

    private final Queue<C0FPacketConfirmTransaction> packetQueue = new ConcurrentLinkedQueue<>();
    private final Queue<Packet<INetHandlerPlayClient>> intaveFlyPackets = new LinkedBlockingQueue<>();
    private boolean intaveMove = false;
    private boolean intaveAttack = false;
    private EntityLivingBase lastIntaveTarget = null;
    private boolean shouldDelayIntaveFly = false;

    public IntaveDisabler(String name, @NotNull Disabler parent) {
        super(name, parent);
        this.registerSetting(intaveOld = new ButtonSetting("Intave Old", true));
        this.registerSetting(intaveCloudCheck = new ButtonSetting("Intave Cloud Check", false));
        this.registerSetting(intaveReach = new ButtonSetting("Intave Reach", false, intaveOld::isToggled));
        this.registerSetting(intaveReachStrong = new ButtonSetting("Intave Reach Strong", false, intaveReach::isToggled));
        this.registerSetting(intaveFly = new ButtonSetting("Intave Fly", false));
    }

    @Override
    public void onDisable() {
        packetQueue.clear();
        intaveFlyPackets.clear();
        intaveMove = false;
        intaveAttack = false;
        lastIntaveTarget = null;
        shouldDelayIntaveFly = false;
    }

    private EntityLivingBase getIntaveTarget() {
        return lastIntaveTarget;
    }

    @SubscribeEvent(priority = EventPriority.LOWEST)
    public void onReceivePacket(@NotNull ReceivePacketEvent event) {
        Packet<?> packet = event.getPacket();


        // IntaveFly: on S08 while flying, delay S32
        if (intaveFly.isToggled() && mc.thePlayer != null) {
            if (packet instanceof S08PacketPlayerPosLook) {
                if (mc.thePlayer.capabilities.allowFlying && mc.thePlayer.capabilities.isFlying) {
                    shouldDelayIntaveFly = true;
                }
            }
            if (packet instanceof S32PacketConfirmTransaction && shouldDelayIntaveFly) {
                event.setCanceled(true);
                intaveFlyPackets.add((Packet<INetHandlerPlayClient>) packet);
                return;
            }
        }
    }

    @SubscribeEvent(priority = EventPriority.LOWEST)
    public void onSendPacket(@NotNull SendPacketEvent event) {
        Packet<?> packet = event.getPacket();

        // IntaveOld: cancel resource pack status
        if (intaveOld.isToggled()) {
            if (packet instanceof net.minecraft.network.play.client.C19PacketResourcePackStatus) {
                event.setCanceled(true);
                return;
            }
        }

        // IntaveCloudCheck: queue C0F on send, batch send at 50
        if (intaveCloudCheck.isToggled()) {
            if (packet instanceof C0FPacketConfirmTransaction) {
                event.setCanceled(true);
                packetQueue.add((C0FPacketConfirmTransaction) packet);
                if (packetQueue.size() >= 50) {
                    C0FPacketConfirmTransaction p = packetQueue.poll();
                    if (p != null) PacketUtils.sendPacketNoEvent(p);
                }
                return;
            }
        }

        // IntaveReach: cancel C02/C0A when distance > 3, position spoof on C03
        if (intaveOld.isToggled() && intaveReach.isToggled() && mc.thePlayer != null) {
            EntityLivingBase target = getIntaveTarget();
            if (packet instanceof C02PacketUseEntity || packet instanceof C0APacketAnimation) {
                if (target == null) {
                    event.setCanceled(true);
                    return;
                }
                if (mc.thePlayer.getDistanceToEntity(target) > 3.0 && ModuleManager.killAura != null && ModuleManager.killAura.isEnabled()) {
                    event.setCanceled(true);
                    return;
                }
            }
            // Position spoof: when intaveMove set, cancel C03 and send fake pos packets
            if (packet instanceof C03PacketPlayer && intaveMove) {
                intaveMove = false;
                intaveAttack = true;
                target = getIntaveTarget();
                if (target != null) {
                    event.setCanceled(true);
                    float[] rots = RotationUtils.getRotations(target);
                    int count = intaveReachStrong.isToggled() ? 20 : 2;
                    for (int i = 0; i < count; i++) {
                        PacketUtils.sendPacketNoEvent(new C03PacketPlayer.C06PacketPlayerPosLook(
                            target.posX, target.posY, target.posZ, rots != null ? rots[0] : 0, rots != null ? rots[1] : 0, true));
                    }
                    PacketUtils.sendPacketNoEvent(new C0APacketAnimation());
                    PacketUtils.sendPacketNoEvent(new C02PacketUseEntity(target, C02PacketUseEntity.Action.ATTACK));
                }
            }
        }
    }

    /**
     * Call from KillAura when attacking - sets lastIntaveTarget and may trigger intaveMove.
     */
    public void onKillAuraAttack(EntityLivingBase target) {
        if (!intaveOld.isToggled() || !intaveReach.isToggled()) return;
        lastIntaveTarget = target;
        if (target != null && mc.thePlayer != null && mc.thePlayer.getDistanceToEntity(target) > 3.0) {
            intaveMove = true;
        }
    }

    @SubscribeEvent
    public void onTick(net.minecraftforge.fml.common.gameevent.TickEvent.ClientTickEvent event) {
        if (!intaveFly.isToggled() || !shouldDelayIntaveFly) return;
        // Periodically release delayed S32 packets
        if (!intaveFlyPackets.isEmpty()) {
            Packet<?> p = intaveFlyPackets.poll();
            if (p != null) PacketUtils.receivePacketNoEvent((Packet<INetHandlerPlayClient>) p);
        }
    }
}
